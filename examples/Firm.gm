/*
 * Project:     GRS
 * File name:   firm.grg
 * Purpose:     A specification of firm,
 *		as well as some optimizing graph replacements.
 * Author:      Rubino Geiss
 * Mowified by:
 * Created:     10.9.2003
 * Copyright:   (c) 2003 Universitaet Karlsruhe
 * Licence:     GPL
 */

model Firm;

node class FIRM_node extends Node {
	generation: int;
}

edge class FIRM_edge extends Edge {
	generation: int;
}


/**********************************************
 * Modes                                      *
 **********************************************/

enum ENUM_sort { 
	auxiliary, control_flow, memory, internal_boolean, 
	int_number, float_number, reference, character 
}
enum ENUM_arithmetic_kind { 
	uninitialized, none, twos_complement, ones_complement, 
	int_BCD, ieee754, float_BCD, max, unknown 
}
enum ENUM_modecode {
	irm_BB, irm_X,   irm_F,   irm_D,  irm_E,  irm_Bs,
	irm_Bu, irm_Hs,  irm_Hu,  irm_Is, irm_Iu, irm_Ls,
	irm_Lu, irm_C,   irm_P,   irm_b,  irm_M,  irm_T,
	irm_U,  irm_ANY, irm_BAD, irm_max
}

const node class Mode extends FIRM_node {
	name            : string;
	size		: int;
	align		: int;
	sort		: ENUM_sort;
	code		: ENUM_modecode;
	sign		: boolean;
	arithmetic	: ENUM_arithmetic_kind;
	shift		: int;
}


/**********************************************
 * Types                                      *
 **********************************************/

enum ENUM_state       { layout_undefined, layout_fixed }

/************* Type Nodes         *************/ 

node class Type extends FIRM_node {
	id    : int;
	name  : string;
	state : ENUM_state;
	size  : int;
}

node class Compound extends Type; 
node class Class extends Compound;
node class Struct extends Compound;
node class Union extends Compound;
node class Method extends Type {
	n_params : int;		// number of calling paramters
	n_ress   : int;		// number of results
	variadic : boolean;	// true: additional variadic parameters allowed
}
node class Array extends Type {
	n_dimensions : int;
}
node class Enum extends Type;
node class Pointer extends Type;
node class Primitive extends Type;

/************* Type Edges         *************/ 

// Class (Sub) -> Class (Super)
edge class is_subtype_of extends FIRM_edge
	connect Class [*] -> Class [*]; 	// Subclass -> Superclass
edge class member extends FIRM_edge
	connect	Compound [*] -> Entity [1];
edge class parameter extends FIRM_edge 
	connect	Method [*] -> Type [*] {
	position : int;
}
edge class result extends FIRM_edge 
	connect Method [*] -> Type [*] {
	position : int; 
}
edge class element_type extends FIRM_edge
	connect	Array [1] -> Type [*];
edge class element_ent extends FIRM_edge
	connect	Array [1] -> Entity [*];
edge class lower extends FIRM_edge 		// TODO: multidim arrays???
	connect	Array [1] -> IR_node [*];
edge class upper extends FIRM_edge
	connect	Array [1] -> IR_node [*];
edge class named_value extends FIRM_edge 	// Enum -> Tarval
	connect Enum [*] -> Tarval [*] {	// TODO: empty Enums [+]???
	name : string;
}
edge class has_type extends FIRM_edge
	connect	Call     [1] -> Type [*],
		FuncCall [1] -> Type [*],
		SymConst [1] -> Type [*],
		Pointer  [1] -> Type [*];


/**********************************************
 * Tarval                                     *
 **********************************************/

node class Tarval extends FIRM_node { 
	value : string;		//  is this aprobate
}

edge class has_mode extends FIRM_edge
	connect	Tarval    [1] -> Mode [*],
		Pointer   [1] -> Mode [*],
		Primitive [1] -> Mode [*];
edge class has_entity extends FIRM_edge
	connect	Tarval [1] -> Entity [*];


/**********************************************
 * Entities                                   *
 **********************************************/

enum ENUM_allocation   { automatic, parameter, dynamic, static }
enum ENUM_visibility   { local, global, extern }
enum ENUM_variability  { uninitialized, initialized, partly_constant, constant }
enum ENUM_peculiarity  { description, inherited, existent }

/************* Entity Nodes       *************/ 

node class Entity extends FIRM_node {
	name        : string;		// the (source) name of the entity
	ld_name     : string;		// the linker name of the entity
	offset      : int;
	allocation  : ENUM_allocation;
	visibility  : ENUM_visibility;
	variability : ENUM_variability;
	peculiarity : ENUM_peculiarity;
	volatility  : boolean;
}

/************* Entity Edges       *************/ 

edge class overwrites extends FIRM_edge
	connect Entity -> Entity;		// TODO arity ???

edge class init_node extends FIRM_edge;
//	connect Entity -> Node (of Init);	// TODO arity ???

edge class init_entity extends FIRM_edge;
//	connect Entity -> Entity (of Init);	// TODO arity ???

edge class graph extends FIRM_edge
	connect Entity [1] -> Method_IRG [*];

edge class type extends FIRM_edge
	connect Entity [1] -> Type [*];


/**********************************************
 * Method IRG                                 *
 **********************************************/

/*
 * Firm IRG the IR graph of a method.
 * Pointing to Start and End nodes as well as its Entity
 */
node class Method_IRG extends FIRM_node {
	main_method : boolean;	// set, if this method is the main entry point
}

edge class meth_start extends FIRM_edge
	connect Method_IRG -> Start;

edge class meth_end extends FIRM_edge
	connect Method_IRG -> End;

edge class frame_type extends FIRM_edge
	connect Method_IRG -> Type;

edge class belong_to extends FIRM_edge
	connect Block -> Method_IRG;

node class IR_node extends FIRM_node {
	arity : int;
}

node class Ordinary;
node class Special;
node class Arithmetic extends Ordinary;
node class Controlflow;
node class Memory;

node class Unary;
node class Binary;
node class Nary;


/**********************************************
 * IR Nodes                                   *
 **********************************************/

node class Block extends IR_node, Special;
node class Start extends IR_node, Special;
node class End extends IR_node, Special;

node class Jmp extends IR_node, Controlflow;
node class Cond extends IR_node, Controlflow;
node class Return extends IR_node, Controlflow;
node class Raise extends IR_node, Controlflow;

node class Const extends IR_node, Ordinary {
	value : string;			// tarval coded as string
}

node class SymConst extends IR_node, Ordinary {
	kind    : int;
	ptrinfo : string;
}

node class Sel extends IR_node;
node class InstOf extends IR_node;
node class Call extends IR_node;
node class FuncCall extends IR_node; // TODO may be Ordinary 
node class Add extends IR_node, Arithmetic, Binary;
node class Sub extends IR_node, Arithmetic, Binary;
node class Minus extends IR_node, Arithmetic, Unary;
node class Mul extends IR_node, Arithmetic, Binary;
node class Quot extends IR_node, Arithmetic, Binary;
node class DivMod extends IR_node, Arithmetic, Binary;
node class Div extends IR_node, Arithmetic, Binary;
node class Mod extends IR_node, Arithmetic, Binary;
node class Abs extends IR_node, Arithmetic, Binary;
node class And extends IR_node, Arithmetic, Binary;
node class Or extends IR_node, Arithmetic, Binary;
node class Eor extends IR_node, Arithmetic, Binary;
node class Not extends IR_node, Arithmetic, Unary;
node class Cmp extends IR_node, Ordinary;
node class Shl extends IR_node, Arithmetic, Binary;
node class Shr extends IR_node, Arithmetic, Binary;
node class Shrs extends IR_node, Arithmetic, Binary;
node class Rot extends IR_node, Arithmetic, Binary;
node class Conv extends IR_node, Ordinary;
node class Cast extends IR_node; // TODO classify
node class Phi extends IR_node, Ordinary;

node class Load extends IR_node, Memory;
node class Store extends IR_node, Memory;

enum ENUM_alloc_where { stack_alloc, heap_alloc }

node class Alloc extends IR_node, Memory {
	where : ENUM_alloc_where;
}
node class Free extends IR_node, Memory;
node class Sync extends IR_node, Memory;

node class Proj extends IR_node, Ordinary {
	proj : int;
}

// TODO classify the following IR_nodes
node class Tuple extends IR_node;
node class Id extends IR_node;
node class Bad extends IR_node;
node class Confirm extends IR_node;
node class Unknown extends IR_node;
node class Filter extends IR_node;
node class Break extends IR_node, Controlflow;
node class CallBegin extends IR_node;
node class EndReg extends IR_node;
node class EndExcept extends IR_node, Controlflow;

/**********************************************
 * IR Intrinsic Nodes                         *
 **********************************************/
node class Intrinsic extends IR_node, Ordinary;

node class IntrinsicGP  extends Intrinsic;	// a intrinsic with gp registers
node class IntrinsicFP  extends Intrinsic;	// a intrinsic with fp registers
node class IntrinsicMMX extends Intrinsic;	// a intrinsic with mmx registers
node class IntrinsicSSE extends Intrinsic;	// a intrinsic with sse registers

node class max extends IntrinsicGP;	// a max instruction
node class min extends IntrinsicGP;	// a min instruction

node class CMOV extends IntrinsicGP;	// a conditional move instruction


/************* IR Edges         *************/ 

edge class flow extends FIRM_edge 
	connect IR_node [*] -> IR_node [*] {
	position : int;
}

edge class df extends flow;		// IR_node -> IR_node, data flow
edge class mem extends df;		// IR_node -> IR_node, memory
edge class cf extends flow		// control flow 
	connect Block -> IR_node;
	
/**********************************************
 * Extensions                                 *
 **********************************************/

node class Vector extends IR_node;

node class V2 extends Vector;
node class V4 extends Vector;

node class pi;

node class V2pi_1 extends V2, pi;
node class V2pi_2 extends V2, pi;

node class V4pi_1 extends V4, pi;
node class V4pi_2 extends V4, pi;
node class V4pi_3 extends V4, pi;
node class V4pi_4 extends V4, pi;

node class V2Load extends V2;
node class V2Store extends V2;

node class V2Sub extends V2;

