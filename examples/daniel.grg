actions FirmAct using Daniel, Firm;
/*
//=====================================================
//
//   Example to get the max degree of a graph
//
//=====================================================

// Add a counter with count 0 to the graph if it's empty
rule add_initial_counter {
    pattern {
        negative { n: Node; }
    }
    replace {
        c: Counter;
    }
//    eval { c.count = 0; }
}

// Add counters to all Ex_Nodes
rule add_counter {
    pattern {
        a: Ex_Node;

        negative { a --> c: Counter; }
    }
    replace { a --> c: Counter; }
//    eval { c.count = 0; }
}

// Remove an edge between two Ex_Nodes and increment their
// counters. Reflexiv edges are covered by (x~y), allowing
// non injective matches. This rule is only applicable if
// the two Ex_Nodes have attached counters already.
rule count_an_edge {
    pattern {
        node (x~y): Ex_Node;
        node (xc, yc): Counter;
        xc <-- x --> y --> yc;
    }
    replace {
        xc <-- x;    y --> yc;
    }
    eval {
//        xc.count = xc.count + 1;
//        yc.count = yc.count + 1;
    }
}

// If an Ex_Node has no more edges to remove then remove
// this Ex_Node. This rule is only applicable if all edges
// of this node have been counted.
rule remove_finished_nodes {
    pattern {
        node x: Ex_Node;
        node xc: Counter;
        x --> xc;

        negative {
            x --> y: Ex_Node;
        }
        negative {
            x <-- z: Ex_Node;
        }
    }
    replace {
        xc;
    }
}

// If a counter isn't attached to an Ex_Node its value may be
// compared to other counters. Remove the counter having the
// smaller value.
rule kill_lesser_counters {
    pattern {
        xc: Counter;
        yc: Counter;

        if xc.count <= yc.count;

        negative {
            node x: Ex_Node;
            x --> xc;
        }
        negative {
            node y: Ex_Node;
            y --> yc;
        }
    }
    replace {
        yc;
    }
}


//=====================================================
//
//   Some special cases
//
//=====================================================

test only_edge {
	pattern {
		a: Node;
		b: Node;
		negative {
			a --> b;
		}
	}
}

test no_correlation {
	pattern {
		a: Node --> b: Node;
		negative {
			c: Add;
		}
	}
}

test multiple_negs {
	pattern {
		a: Node --> b: Node;

		negative {
			a --> c: Node;
		}
		negative {
			b --> c: Node; //this c is diffrent from 3 lines above.
		}
		negative {
			a <-- b; //revers edge
		}
	}
}

// This selects all nodes which do not have a counter attatched
// with a count of zero. It can match nodes which have a counter
// with count 23 for example.
test cond_in_neg {
	pattern {
		a: Node;
		negative {
			a --> c: Counter;
			if c.count == 0;
		}
	}
}

test subgraph_as_neg {
	pattern {
		node (a, b): Node;
		a --> b;
		negative { a; }
	}
}
*/
//=====================================================
//
//   Speed testing stuff
//
//=====================================================

// Add counters to all IR_nodes
rule counter {
    pattern {
        a: IR_node;

        negative { a --> c: Counter; }
    }
    replace { a --> c: Counter; }
//    eval { c.count = 0; }
}

// Dead code elimination
rule dce {
  pattern {
    a: Ordinary;
    negative {
      a <-:flow- x: IR_node;
    }
    negative {
      a -:mem -> x: IR_node;
    }
  }
  replace {
    //empty to delete n
  }
}

test loop_3 {
	pattern {
		node (a,b,c): Node;
		a --> b --> c --> a;
		negative { a --> b -->a; }
		negative { a --> c -->a; }
		negative { b --> c -->b; }
	}
}

test fancy {
	pattern {
		a: Node;
		node (b,c,d,e): Node;
		a -:df-> b -:df-> c -:df-> d -:df-> e;
		a -:df-> c;
		b -:df-> d;
		c -:df-> e;
/*		negative {
			x: Node;
			d --> x <-- f;
		}*/
	}
}


