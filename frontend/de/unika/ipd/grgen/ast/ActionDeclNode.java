/*
 * GrGen: graph rewrite generator tool -- release GrGen.NET 4.5
 * Copyright (C) 2003-2020 Universitaet Karlsruhe, Institut fuer Programmstrukturen und Datenorganisation, LS Goos; and free programmers
 * licensed under LGPL v3 (see LICENSE.txt included in the packaging of this file)
 * www.grgen.net
 */

/**
 * @author shack
 */

package de.unika.ipd.grgen.ast;

import de.unika.ipd.grgen.ir.Rule;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;

/**
 * Base class for all action type ast nodes
 */
// TODO: a lot of code duplication among the subtypes of ActionDeclNode,
// fix the copy'n'paste programming by extracting the common stuff to action node,
// with parameters giving access to the left/right patterns.
// First step: remove the ability for multiple right sides, not needed in practice (0 or 1 RHS allowed)
// (maybe a test must be modeled as a rule with 0 RHS in order to be able to unify with the other action decl nodes)
public abstract class ActionDeclNode extends DeclNode
{
	protected PatternGraphNode pattern;

	public ActionDeclNode(IdentNode id, TypeNode type, PatternGraphNode left) {
		super(id, type);

		this.pattern = left;
		becomeParent(this.pattern);
	}

	/**
	 * Get the IR object for this action node.
	 * The IR object is instance of Rule.
	 * @return The IR object.
	 */
	protected Rule getAction() {
		return checkIR(Rule.class);
	}

	protected PatternGraphNode getParentPatternGraph(BaseNode node) {
		if (node == null) {
			return null;
		}

		Queue<Collection<BaseNode>> queue = new LinkedList<Collection<BaseNode>>();
		for (Collection<BaseNode> parents = node.getParents(); parents != null; parents = queue.poll()) {
			for (BaseNode parent : parents) {
				if (parent instanceof PatternGraphNode) {
					return (PatternGraphNode)parent;
				}
				Collection<BaseNode> grandParents = parent.getParents();
				if (grandParents != null && !grandParents.isEmpty()) {
					queue.add(grandParents);
				}
			}
		}

		return null;
	}

	protected boolean resolveFilters(ArrayList<FilterAutoNode> filters) {
		boolean filtersOk = true;
		for(FilterAutoNode filter : filters) {
			if(filter instanceof FilterAutoSuppliedNode) {
				filtersOk &= ((FilterAutoSuppliedNode)filter).resolve();
			} else { //if(filter instanceof FilterAutoGeneratedNode)
				filtersOk &= ((FilterAutoGeneratedNode)filter).resolve();
			}
		}
		return filtersOk;
	}

	protected boolean checkFilters(PatternGraphNode pattern, ArrayList<FilterAutoNode> filters) {
		boolean allFilterEntitiesExistAndAreOfAdmissibleType = true;
		HashSet<String> alreadySeenFilters = new HashSet<String>();
		for(FilterAutoNode fa : filters) {
			if(fa instanceof FilterAutoGeneratedNode) {
				FilterAutoGeneratedNode filter = (FilterAutoGeneratedNode)fa;
				String filterNameWithEntitySuffix = filter.getFilterNameWithEntitySuffix();
				if(alreadySeenFilters.contains(filterNameWithEntitySuffix)) {
					reportError(filterNameWithEntitySuffix + " was already declared, only one declaration admissible.");
					allFilterEntitiesExistAndAreOfAdmissibleType = false;
				} else {
					alreadySeenFilters.add(filterNameWithEntitySuffix);
				}
				if(filter.name.equals("orderAscendingBy") || filter.name.equals("orderDescendingBy")
					|| filter.name.equals("groupBy") || filter.name.equals("keepSameAsFirst")
					|| filter.name.equals("keepSameAsLast") || filter.name.equals("keepOneForEach")) {
					for(String filterEntity : filter.entities) {
						allFilterEntitiesExistAndAreOfAdmissibleType &= checkFilterVariable(pattern, filterNameWithEntitySuffix, filterEntity);
					}
					if(filter.name.equals("groupBy") || filter.name.equals("keepSameAsFirst")
						|| filter.name.equals("keepSameAsLast") || filter.name.equals("keepOneForEach")) {
						if(filter.entities.size()!=1) {
							reportError(filterNameWithEntitySuffix + " must be declared with exactly one variable, but is declared with " + filter.entities.size() + " variables");
							allFilterEntitiesExistAndAreOfAdmissibleType = false;
						}
					}
				}
			}
		}
		return allFilterEntitiesExistAndAreOfAdmissibleType;
	}

	private boolean checkFilterVariable(PatternGraphNode pattern, String filterNameWithEntitySuffix, String filterVariable) {
		if(pattern.getVariable(filterVariable)==null) {
			reportError(filterNameWithEntitySuffix + ": unknown variable " + filterVariable);
			return false;
		}
		TypeNode filterVariableType = pattern.getVariable(filterVariable).getDeclType();
		if(!filterVariableType.isFilterableType()) {
			reportError(filterNameWithEntitySuffix + ": the variable " + filterVariable + " must be of one of the following types: " + filterVariableType.getFilterableTypesAsString());
			return false;
		}
		return true;
	}
	
	protected boolean checkLeft() {
		// check if reused names of edges connect the same nodes in the same direction with the same edge kind for each usage
		boolean edgeReUse = false;
		edgeReUse = true;

		//get the negative graphs and the pattern of this TestDeclNode
		// NOTE: the order affect the error coords
		Collection<PatternGraphNode> leftHandGraphs = new LinkedList<PatternGraphNode>();
		leftHandGraphs.add(pattern);
		for (PatternGraphNode pgn : pattern.negs.getChildren()) {
			leftHandGraphs.add(pgn);
		}

		GraphNode[] graphs = leftHandGraphs.toArray(new GraphNode[0]);
		Collection<EdgeCharacter> alreadyReported = new HashSet<EdgeCharacter>();

		for (int i=0; i<graphs.length; i++) {
			for (int o=i+1; o<graphs.length; o++) {
				for (BaseNode iBN : graphs[i].getConnections()) {
					if (! (iBN instanceof ConnectionNode)) {
						continue;
					}
					ConnectionNode iConn = (ConnectionNode)iBN;

					for (BaseNode oBN : graphs[o].getConnections()) {
						if (! (oBN instanceof ConnectionNode)) {
							continue;
						}
						ConnectionNode oConn = (ConnectionNode)oBN;

						if (iConn.getEdge().equals(oConn.getEdge()) && !alreadyReported.contains(iConn.getEdge())) {
							NodeCharacter oSrc, oTgt, iSrc, iTgt;
							oSrc = oConn.getSrc();
							oTgt = oConn.getTgt();
							iSrc = iConn.getSrc();
							iTgt = iConn.getTgt();

							assert ! (oSrc instanceof NodeTypeChangeNode):
								"no type changes in test actions";
							assert ! (oTgt instanceof NodeTypeChangeNode):
								"no type changes in test actions";
							assert ! (iSrc instanceof NodeTypeChangeNode):
								"no type changes in test actions";
							assert ! (iTgt instanceof NodeTypeChangeNode):
								"no type changes in test actions";

							//check only if there's no dangling edge
							if ( !((iSrc instanceof NodeDeclNode) && ((NodeDeclNode)iSrc).isDummy())
								&& !((oSrc instanceof NodeDeclNode) && ((NodeDeclNode)oSrc).isDummy())
								&& iSrc != oSrc ) {
								alreadyReported.add(iConn.getEdge());
								iConn.reportError("Reused edge does not connect the same nodes");
								edgeReUse = false;
							}

							//check only if there's no dangling edge
							if ( !((iTgt instanceof NodeDeclNode) && ((NodeDeclNode)iTgt).isDummy())
								&& !((oTgt instanceof NodeDeclNode) && ((NodeDeclNode)oTgt).isDummy())
								&& iTgt != oTgt && !alreadyReported.contains(iConn.getEdge())) {
								alreadyReported.add(iConn.getEdge());
								iConn.reportError("Reused edge does not connect the same nodes");
								edgeReUse = false;
							}


							if (iConn.getConnectionKind() != oConn.getConnectionKind()) {
								alreadyReported.add(iConn.getEdge());
								iConn.reportError("Reused edge does not have the same connection kind");
								edgeReUse = false;
							}
						}
					}
				}
			}
		}

		return edgeReUse;
	}
}
