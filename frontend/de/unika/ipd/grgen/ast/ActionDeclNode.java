/*
 * GrGen: graph rewrite generator tool -- release GrGen.NET 5.0
 * Copyright (C) 2003-2020 Universitaet Karlsruhe, Institut fuer Programmstrukturen und Datenorganisation, LS Goos; and free programmers
 * licensed under LGPL v3 (see LICENSE.txt included in the packaging of this file)
 * www.grgen.net
 */

/**
 * @author shack
 */

package de.unika.ipd.grgen.ast;

import de.unika.ipd.grgen.ast.containers.ArrayAccumulationMethodNode;
import de.unika.ipd.grgen.ast.exprevals.DeclExprNode;
import de.unika.ipd.grgen.ast.exprevals.ExprNode;
import de.unika.ipd.grgen.ir.Alternative;
import de.unika.ipd.grgen.ir.Edge;
import de.unika.ipd.grgen.ir.Entity;
import de.unika.ipd.grgen.ir.MatchingAction;
import de.unika.ipd.grgen.ir.Node;
import de.unika.ipd.grgen.ir.PatternGraph;
import de.unika.ipd.grgen.ir.Rule;
import de.unika.ipd.grgen.ir.Variable;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Set;
import java.util.Vector;

/**
 * Base class for all action type ast nodes
 */
public abstract class ActionDeclNode extends DeclNode
{
	protected PatternGraphNode pattern;

	public ActionDeclNode(IdentNode id, TypeNode type, PatternGraphNode left) {
		super(id, type);

		this.pattern = left;
		becomeParent(this.pattern);
	}

	/**
	 * Get the IR object for this action node.
	 * The IR object is instance of Rule.
	 * @return The IR object.
	 */
	protected Rule getAction() {
		return checkIR(Rule.class);
	}

	protected PatternGraphNode getParentPatternGraph(BaseNode node) {
		if(node == null) {
			return null;
		}

		Queue<Collection<BaseNode>> queue = new LinkedList<Collection<BaseNode>>();
		for(Collection<BaseNode> parents = node.getParents(); parents != null; parents = queue.poll()) {
			for(BaseNode parent : parents) {
				if(parent instanceof PatternGraphNode) {
					return (PatternGraphNode)parent;
				}
				Collection<BaseNode> grandParents = parent.getParents();
				if(grandParents != null && !grandParents.isEmpty()) {
					queue.add(grandParents);
				}
			}
		}

		return null;
	}

	protected boolean resolveFilters(ArrayList<FilterAutoNode> filters) {
		boolean filtersOk = true;
		for(FilterAutoNode filter : filters) {
			if(filter instanceof FilterAutoSuppliedNode) {
				filtersOk &= ((FilterAutoSuppliedNode)filter).resolve();
			} else { //if(filter instanceof FilterAutoGeneratedNode)
				filtersOk &= ((FilterAutoGeneratedNode)filter).resolve();
			}
		}
		return filtersOk;
	}

	protected boolean checkFilters(PatternGraphNode pattern, ArrayList<FilterAutoNode> filters) {
		boolean filtersOk = true;
		for(FilterAutoNode filter : filters) {
			if(filter instanceof FilterAutoSuppliedNode) {
				filtersOk &= ((FilterAutoSuppliedNode)filter).check();
			} else { //if(filter instanceof FilterAutoGeneratedNode)
				filtersOk &= ((FilterAutoGeneratedNode)filter).check();
			}
		}
		boolean allFilterEntitiesExistAndAreOfAdmissibleType = true;
		HashSet<String> alreadySeenFilters = new HashSet<String>();
		for(FilterAutoNode fa : filters) {
			if(fa instanceof FilterAutoGeneratedNode) {
				FilterAutoGeneratedNode filter = (FilterAutoGeneratedNode)fa;
				String filterNameWithEntitySuffix = filter.getFilterNameWithEntitySuffix();
				if(alreadySeenFilters.contains(filterNameWithEntitySuffix)) {
					reportError(filterNameWithEntitySuffix + " was already declared, only one declaration admissible.");
					allFilterEntitiesExistAndAreOfAdmissibleType = false;
				} else {
					alreadySeenFilters.add(filterNameWithEntitySuffix);
				}
				allFilterEntitiesExistAndAreOfAdmissibleType &= checkAutoGeneratedFilter(filter);
			}
		}
		return filtersOk & allFilterEntitiesExistAndAreOfAdmissibleType;
	}

	protected boolean checkAutoGeneratedFilter(FilterAutoGeneratedNode filter) {
		String filterNameWithEntitySuffix = filter.getFilterNameWithEntitySuffix();
		if(filter.name.equals("orderAscendingBy") || filter.name.equals("orderDescendingBy")) {
			boolean allFilterEntitiesExistAndAreOfAdmissibleType = true;
			for(String filterEntity : filter.entities) {
				allFilterEntitiesExistAndAreOfAdmissibleType &= pattern.checkFilterVariable(getIdentNode(), filterNameWithEntitySuffix, filterEntity);
			}
			return allFilterEntitiesExistAndAreOfAdmissibleType;
		} else if(filter.name.equals("keepOneForEach") || filter.name.equals("groupBy")
				|| filter.name.equals("keepSameAsFirst") || filter.name.equals("keepSameAsLast")) {
			boolean allFilterEntitiesExistAndAreOfAdmissibleType = true;
			for(String filterEntity : filter.entities) {
				allFilterEntitiesExistAndAreOfAdmissibleType &= pattern.checkFilterEntity(getIdentNode(), filterNameWithEntitySuffix, filterEntity);
			}
			if(filter.entities.size()!=1) {
				reportError(filterNameWithEntitySuffix + " must be declared with exactly one variable, but is declared with " + filter.entities.size() + " variables");
				allFilterEntitiesExistAndAreOfAdmissibleType = false;
			}
			return allFilterEntitiesExistAndAreOfAdmissibleType;
		} else if(filter.name.equals("keepOneForEachAccumulateBy")) {
			if(filter.entities.size() != 3) {
				getIdentNode().reportError(filterNameWithEntitySuffix + " must be declared with exactly one variable, one accumulation variable, and one accumulation method");
				return false;
			} else {
				if(filter.entities.get(0).equals(filter.entities.get(1))) {
					getIdentNode().reportError("The accumulation variable " + filter.entities.get(1) + " must be different from the variable.");
					return false;
				}
				boolean filterEntityExistsAndIsOfAdmissibleType = pattern.checkFilterEntity(getIdentNode(), filterNameWithEntitySuffix, filter.entities.get(0));
				if(!filterEntityExistsAndIsOfAdmissibleType)
					return false;
				ArrayAccumulationMethodNode accumulationMethod = ArrayAccumulationMethodNode.getArrayMethodNode(filter.entities.get(2));
				if(accumulationMethod == null) {
					getIdentNode().reportError("The array accumulation method " + filter.entities.get(2) + " is not known.");
					return false;
				}
				VarDeclNode filterAccumulationVariable = pattern.tryGetVar(filter.entities.get(1));
				if(filterAccumulationVariable == null) {
					getIdentNode().reportError(filterNameWithEntitySuffix + ": unknown accumulation variable " + filter.entities.get(1));
					return false;
				}
				TypeNode filterAccumulationVariableType = filterAccumulationVariable.getDeclType();
				if(!accumulationMethod.isValidTargetTypeOfAccumulation(filterAccumulationVariableType)) {
					getIdentNode().reportError("The array accumulation method " + filter.entities.get(2)
						+ " is not applicable to the type " + filterAccumulationVariableType + " of the accumulation variable " 
						+ filter.entities.get(1) + " / its result cannot be assigned to the accumulation variable."
						+ " (Accumulatable are: " + TypeNode.getAccumulatableTypesAsString()
						+ "; a valid target type for all accumulation methods is double)");
					return false;
				}
				return true;
			}
		} else if(filter.name.equals("auto")) {
			return true; // skip
		} else {
			assert(false);
			return false;
		}
	}

	protected boolean checkLeft() {
		// check if reused names of edges connect the same nodes in the same direction with the same edge kind for each usage
		boolean isLhsEdgeReuseOk = true;

		//get the negative and independent graphs and the pattern of this TestDeclNode
		// NOTE: the order affect the error coords
		Collection<PatternGraphNode> leftHandGraphs = new LinkedList<PatternGraphNode>();
		leftHandGraphs.add(pattern);
		for(PatternGraphNode neg : pattern.negs.getChildren()) {
			leftHandGraphs.add(neg);
		}
		for(PatternGraphNode idpt : pattern.idpts.getChildren()) {
			leftHandGraphs.add(idpt);
		}

		GraphNode[] graphs = leftHandGraphs.toArray(new GraphNode[0]);
		Collection<EdgeCharacter> alreadyReported = new HashSet<EdgeCharacter>();

		for(int i=0; i<graphs.length; i++) {
			for(int o=i+1; o<graphs.length; o++) {
				for(BaseNode iBN : graphs[i].getConnections()) {
					if(!(iBN instanceof ConnectionNode)) {
						continue;
					}
					ConnectionNode iConn = (ConnectionNode)iBN;

					for(BaseNode oBN : graphs[o].getConnections()) {
						if(!(oBN instanceof ConnectionNode)) {
							continue;
						}
						ConnectionNode oConn = (ConnectionNode)oBN;

						if(iConn.getEdge().equals(oConn.getEdge()) && !alreadyReported.contains(iConn.getEdge())) {
							isLhsEdgeReuseOk &= isLhsEdgeReuseOk(alreadyReported, iConn, oConn);
						}
					}
				}
			}
		}

		return isLhsEdgeReuseOk;
	}

	private boolean isLhsEdgeReuseOk(Collection<EdgeCharacter> alreadyReported, 
			ConnectionNode iConn, ConnectionNode oConn) {
		boolean edgeReuse = true;
		
		NodeCharacter oSrc = oConn.getSrc();
		NodeCharacter oTgt = oConn.getTgt();
		NodeCharacter iSrc = iConn.getSrc();
		NodeCharacter iTgt = iConn.getTgt();

		assert !(oSrc instanceof NodeTypeChangeNode):
			"no type changes in test actions";
		assert !(oTgt instanceof NodeTypeChangeNode):
			"no type changes in test actions";
		assert !(iSrc instanceof NodeTypeChangeNode):
			"no type changes in test actions";
		assert !(iTgt instanceof NodeTypeChangeNode):
			"no type changes in test actions";

		//check only if there's no dangling edge
		if(!( (iSrc instanceof NodeDeclNode) && ((NodeDeclNode)iSrc).isDummy() )
			&& !( (oSrc instanceof NodeDeclNode) && ((NodeDeclNode)oSrc).isDummy() )
			&& iSrc != oSrc) {
			alreadyReported.add(iConn.getEdge());
			iConn.reportError("Reused edge does not connect the same nodes");
			edgeReuse = false;
		}

		//check only if there's no dangling edge
		if(!( (iTgt instanceof NodeDeclNode) && ((NodeDeclNode)iTgt).isDummy() )
			&& !( (oTgt instanceof NodeDeclNode) && ((NodeDeclNode)oTgt).isDummy() )
			&& iTgt != oTgt && !alreadyReported.contains(iConn.getEdge())) {
			alreadyReported.add(iConn.getEdge());
			iConn.reportError("Reused edge does not connect the same nodes");
			edgeReuse = false;
		}

		if(iConn.getConnectionKind() != oConn.getConnectionKind()) {
			alreadyReported.add(iConn.getEdge());
			iConn.reportError("Reused edge does not have the same connection kind");
			edgeReuse = false;
		}
		
		return edgeReuse;
	}
	
	/** Checks, whether the reused nodes and edges of the RHS are consistent with the LHS.
	 * If consistent, replace the dummy nodes with the nodes the pattern edge is
	 * incident to (if these aren't dummy nodes themselves, of course). */
	protected boolean checkRhsReuse(RhsDeclNode right) {
		boolean res = true;

		HashMap<EdgeDeclNode, NodeDeclNode> redirectedFrom = new HashMap<EdgeDeclNode, NodeDeclNode>();
		HashMap<EdgeDeclNode, NodeDeclNode> redirectedTo = new HashMap<EdgeDeclNode, NodeDeclNode>();

		Collection<EdgeDeclNode> alreadyReported = new HashSet<EdgeDeclNode>();
		for(ConnectionNode rConn : right.getReusedConnections(pattern)) {
			EdgeDeclNode re = rConn.getEdge();

			if(re instanceof EdgeTypeChangeNode) {
				re = ((EdgeTypeChangeNode)re).getOldEdge();
			}

			for(BaseNode lc : pattern.getConnections()) {
				if(!(lc instanceof ConnectionNode)) {
					continue;
				}

				ConnectionNode lConn = (ConnectionNode) lc;

				EdgeDeclNode le = lConn.getEdge();

				if(!le.equals(re)) {
					continue;
				}

				if(lConn.getConnectionKind() != rConn.getConnectionKind()) {
					res = false;
					rConn.reportError("Reused edge does not have the same connection kind");
					// if you don't add to alreadyReported erroneous errors can occur,
					// e.g. lhs=x-e->y, rhs=y-e-x
					alreadyReported.add(re);
				}

				res &= isLhsRhsReuseOk(alreadyReported, redirectedFrom, redirectedTo, right, lConn, le, rConn, re);
			}
		}

		return res;
	}

	private boolean isLhsRhsReuseOk(Collection<EdgeDeclNode> alreadyReported,
			HashMap<EdgeDeclNode, NodeDeclNode> redirectedFrom, HashMap<EdgeDeclNode, NodeDeclNode> redirectedTo, 
			RhsDeclNode right, ConnectionNode lConn, EdgeDeclNode le, ConnectionNode rConn, EdgeDeclNode re) {
		boolean res = true;
		
		NodeDeclNode lSrc = lConn.getSrc();
		NodeDeclNode lTgt = lConn.getTgt();
		NodeDeclNode rSrc = rConn.getSrc();
		NodeDeclNode rTgt = rConn.getTgt();

		HashSet<BaseNode> rhsNodes = new HashSet<BaseNode>();
		rhsNodes.addAll(right.getReusedNodes(pattern));

		if(rSrc instanceof NodeTypeChangeNode) {
			rSrc = ((NodeTypeChangeNode)rSrc).getOldNode();
			rhsNodes.add(rSrc);
		}
		if(rTgt instanceof NodeTypeChangeNode) {
			rTgt = ((NodeTypeChangeNode)rTgt).getOldNode();
			rhsNodes.add(rTgt);
		}

		if(!lSrc.isDummy()) {
			if(rSrc.isDummy()) {
				if(rhsNodes.contains(lSrc)) {
					//replace the dummy src node by the src node of the pattern connection
					rConn.setSrc(lSrc);
				} else if(!alreadyReported.contains(re)) {
					res = false;
					rConn.reportError("The source node of reused edge \"" + le + "\" must be reused, too");
					alreadyReported.add(re);
				}
			} else if(lSrc != rSrc && (rConn.getRedirectionKind() & ConnectionNode.REDIRECT_SOURCE)!=ConnectionNode.REDIRECT_SOURCE && !alreadyReported.contains(re)) {
				res = false;
				rConn.reportError("Reused edge \"" + le + "\" does not connect the same nodes (and is not declared to redirect source)");
				alreadyReported.add(re);
			}
		}
		
		if((rConn.getRedirectionKind() & ConnectionNode.REDIRECT_SOURCE)==ConnectionNode.REDIRECT_SOURCE ) {
			if(rSrc.isDummy()) {
				res = false;
				rConn.reportError("An edge with source redirection must be given a source node.");
			}
			
			if(lSrc.equals(rSrc)) {
				rConn.reportWarning("Redirecting edge to same source again.");
			}
			
			if(redirectedFrom.containsKey(le)) {
				res = false;
				rConn.reportError("Can't redirect edge source more than once.");
			}
			redirectedFrom.put(le, rSrc);
		}

		if(!lTgt.isDummy()) {
			if(rTgt.isDummy()) {
				if(rhsNodes.contains(lTgt)) {
					//replace the dummy tgt node by the tgt node of the pattern connection
					rConn.setTgt(lTgt);
				} else if(!alreadyReported.contains(re)) {
					res = false;
					rConn.reportError("The target node of reused edge \"" + le + "\" must be reused, too");
					alreadyReported.add(re);
				}
			} else if(lTgt != rTgt && (rConn.getRedirectionKind() & ConnectionNode.REDIRECT_TARGET)!=ConnectionNode.REDIRECT_TARGET && !alreadyReported.contains(re)) {
				res = false;
				rConn.reportError("Reused edge \"" + le + "\" does not connect the same nodes (and is not declared to redirect target)");
				alreadyReported.add(re);
			}
		}
		
		if((rConn.getRedirectionKind() & ConnectionNode.REDIRECT_TARGET)==ConnectionNode.REDIRECT_TARGET) {
			if(rTgt.isDummy()) {
				res = false;
				rConn.reportError("An edge with target redirection must be given a target node.");
			}
			
			if(lTgt.equals(rTgt)) {
				rConn.reportWarning("Redirecting edge to same target again.");
			}
			
			if(redirectedTo.containsKey(le)) {
				res = false;
				rConn.reportError("Can't redirect edge target more than once.");
			}
			redirectedTo.put(le, rSrc);
		}

		//check, whether RHS "adds" a node to a dangling end of a edge
		if(!alreadyReported.contains(re)) {
			if(lSrc.isDummy() && !rSrc.isDummy() && (rConn.getRedirectionKind() & ConnectionNode.REDIRECT_SOURCE)!=ConnectionNode.REDIRECT_SOURCE) {
				res = false;
				rConn.reportError("Reused edge dangles on LHS, but has a source node on RHS");
				alreadyReported.add(re);
			}
			if(lTgt.isDummy() && !rTgt.isDummy() && (rConn.getRedirectionKind() & ConnectionNode.REDIRECT_TARGET)!=ConnectionNode.REDIRECT_TARGET) {
				res = false;
				rConn.reportError("Reused edge dangles on LHS, but has a target node on RHS");
				alreadyReported.add(re);
			}
		}
		
		return res;
	}
	
	/**
	 * Check that exec parameters are not deleted.
	 *
	 * The check consider the case that parameters are deleted due to
	 * homomorphic matching.
	 */
	protected boolean checkExecParamsNotDeleted(RhsDeclNode right) {
		assert isResolved();

		boolean valid = true;

		Set<DeclNode> deleted = right.getDeleted(pattern);
		Collection<DeclNode> maybeDeleted = right.getMaybeDeleted(pattern);

		for(BaseNode x : right.graph.imperativeStmts.getChildren()) {
			if(!(x instanceof ExecNode))
				continue;

			ExecNode exec = (ExecNode) x;
			for(CallActionNode callAction : exec.callActions.getChildren()) {
				for(ExprNode arg : callAction.params.getChildren()) {
					if(!(arg instanceof DeclExprNode))
						continue;

					ConstraintDeclNode declNode = ((DeclExprNode) arg).getConstraintDeclNode();
					valid &= checkExecParamNotDeleted(declNode, deleted, maybeDeleted);
				}
			}
		}
		
		return valid;
	}

	private boolean checkExecParamNotDeleted(ConstraintDeclNode declNode,
			Set<DeclNode> deleted, Collection<DeclNode> maybeDeleted) {
		boolean valid = true;
		
		if(declNode != null) {
			if(deleted.contains(declNode)) {
				declNode.reportError("The deleted " + declNode.getUseString()
						+ " \"" + declNode.ident + "\" must not be passed to an exec statement");
				valid = false;
			}
			else if(maybeDeleted.contains(declNode)) {
				declNode.maybeDeleted = true;

				if(!declNode.getIdentNode().getAnnotations().isFlagSet("maybeDeleted")) {
					valid = false;

					String errorMessage = "Parameter \"" + declNode.ident + "\" of exec statement may be deleted"
							+ ", possibly it's homomorphic with a deleted " + declNode.getUseString();
					errorMessage += " (use a [maybeDeleted] annotation if you think that this does not cause problems)";

					if(declNode instanceof EdgeDeclNode) {
						errorMessage += " or \"" + declNode.ident + "\" is a dangling " + declNode.getUseString()
								+ " and a deleted node exists";
					}
					declNode.reportError(errorMessage);
				}
			}
		}
		
		return valid;
	}
	
	protected boolean sameNumberOfRewriteParts(RhsDeclNode right, String actionKind) {
		boolean res = true;

		for(AlternativeNode alt : pattern.alts.getChildren()) {
			for(AlternativeCaseNode altCase : alt.getChildren()) {
				if((right == null) != (altCase.right == null)) {
					error.error(getCoords(), "Different number of replacement patterns/rewrite parts in " + actionKind + " " + ident.toString()
							+ " and nested alternative case " + altCase.ident.toString());
					res = false;
				}
			}
		}

		for(IteratedNode iter : pattern.iters.getChildren()) {
			if((right == null) != (iter.right == null)) {
				error.error(getCoords(), "Different number of replacement patterns/rewrite parts in " + actionKind + " " + ident.toString()
						+ " and nested iterated/multiple/optional " + iter.ident.toString());
				res = false;
			}
		}

		return res;
	}

	protected boolean noNestedRewriteParameters(RhsDeclNode right, String actionKind) {
		boolean res = true;

		for(AlternativeNode alt : pattern.alts.getChildren()) {
			for(AlternativeCaseNode altCase : alt.getChildren()) {
				if(altCase.right == null)
					continue;

				Vector<DeclNode> parametersInNestedAlternativeCase = altCase.right.graph.getParamDecls();

				if(parametersInNestedAlternativeCase.size() != 0) {
					error.error(altCase.getCoords(), "No replacement parameters allowed in nested alternative cases; given in " + altCase.ident.toString());
					res = false;
				}
			}
		}

		for(IteratedNode iter : pattern.iters.getChildren()) {
			if(iter.right == null)
				continue;

			Vector<DeclNode> parametersInNestedIterated = iter.right.graph.getParamDecls();

			if(parametersInNestedIterated.size() != 0) {
				error.error(iter.getCoords(), "No replacement parameters allowed in nested iterated/multiple/optional; given in " + iter.ident.toString());
				res = false;
			}
		}

		return res;
	}
	
	protected boolean noAbstractElementInstantiatedNestedPattern(RhsDeclNode right) {		
		boolean abstr = true;

nodeAbstrLoop:
        for(NodeDeclNode node : right.graph.getNodes()) {
            if(!node.inheritsType() && node.getDeclType().isAbstract()) {
                if((node.context & CONTEXT_PARAMETER) == CONTEXT_PARAMETER) {
                    continue;
                }
                for(PatternGraphNode pattern = this.pattern; pattern != null;
                        pattern = getParentPatternGraph(pattern)) {
                    if(pattern.getNodes().contains(node)) {
                        continue nodeAbstrLoop;
                    }
                }
                error.error(node.getCoords(), "Instances of abstract nodes are not allowed");
                abstr = false;
            }
        }

edgeAbstrLoop:
        for(EdgeDeclNode edge : right.graph.getEdges()) {
            if(!edge.inheritsType() && edge.getDeclType().isAbstract()) {
                if((edge.context & CONTEXT_PARAMETER) == CONTEXT_PARAMETER) {
                    continue;
                }
                for(PatternGraphNode pattern = this.pattern; pattern != null;
                        pattern = getParentPatternGraph(pattern)) {
                    if(pattern.getEdges().contains(edge)) {
                        continue edgeAbstrLoop;
                    }
                }
				error.error(edge.getCoords(), "Instances of abstract edges are not allowed");
				abstr = false;
			}
		}
	
		return abstr;
	}
	
	protected boolean noAbstractElementInstantiated(RhsDeclNode right) {
		boolean abstr = true;

        for(NodeDeclNode node : right.graph.getNodes()) {
            if(!node.inheritsType() && node.getDeclType().isAbstract()
            		&& !pattern.getNodes().contains(node) && (node.context&CONTEXT_PARAMETER)!=CONTEXT_PARAMETER) {
                error.error(node.getCoords(), "Instances of abstract nodes are not allowed");
                abstr = false;
            }
        }
        for(EdgeDeclNode edge : right.graph.getEdges()) {
            if(!edge.inheritsType() && edge.getDeclType().isAbstract()
            		&& !pattern.getEdges().contains(edge) && (edge.context&CONTEXT_PARAMETER)!=CONTEXT_PARAMETER) {
				error.error(edge.getCoords(), "Instances of abstract edges are not allowed");
				abstr = false;
			}
		}
	
		return abstr;
	}
	
	protected void constructIRaux(Rule constructedRule, RhsDeclNode right) {
		// add Params to the IR
		addParams(constructedRule);

		// add replacement parameters to the IR
		PatternGraph rightPattern = null;
		if(right != null) {
			rightPattern = right.getPatternGraph(pattern.getPatternGraph());
		} else {
			return;
		}

		// add replacement parameters to the current graph
		for(DeclNode decl : right.graph.getParamDecls()) {
			if(decl instanceof NodeCharacter) {
				rightPattern.addReplParameter(decl.checkIR(Node.class));
				rightPattern.addSingleNode(((NodeCharacter) decl).getNode());
			} else if(decl instanceof VarDeclNode) {
				rightPattern.addReplParameter(decl.checkIR(Variable.class));
				rightPattern.addVariable(((VarDeclNode) decl).getVariable());
			} else {
				throw new IllegalArgumentException("unknown Class: " + decl);
			}
		}

		// and also to the nested alternatives and iterateds
		if(right != null) {
			addReplacementParamsToNestedAlternativesAndIterateds(constructedRule, right);
		}
	}

	protected void addParams(MatchingAction constructedMatchingAction) {
		PatternGraph patternGraph = constructedMatchingAction.getPattern();

		// (TODO: parameters were already added to the graph -> needed here again (?))
		for(DeclNode decl : pattern.getParamDecls()) {
			Entity entity = decl.checkIR(Entity.class);
			if(entity.isDefToBeYieldedTo())
				constructedMatchingAction.addDefParameter(entity);
			else
				constructedMatchingAction.addParameter(entity);
			if(decl instanceof NodeCharacter) {
				patternGraph.addSingleNode(((NodeCharacter)decl).getNode());
			} else if(decl instanceof EdgeCharacter) {
				Edge e = ((EdgeCharacter)decl).getEdge();
				patternGraph.addSingleEdge(e);
			} else if(decl instanceof VarDeclNode) {
				patternGraph.addVariable(((VarDeclNode) decl).getVariable());
			} else {
				throw new IllegalArgumentException("unknown Class: " + decl);
			}
		}
	}
	
	protected void addReplacementParamsToNestedAlternativesAndIterateds(Rule constructedRule, RhsDeclNode right) {
		// add replacement parameters to the nested alternatives and iterateds
		PatternGraph patternGraph = constructedRule.getPattern();
		for(DeclNode decl : right.graph.getParamDecls()) {
			if(decl instanceof NodeDeclNode) {
				addReplacementNodeParamToNestedAlternativesAndIterateds((NodeDeclNode)decl, patternGraph);
			} else if(decl instanceof VarDeclNode) {
				addReplacementVarParamToNestedAlternativesAndIterateds((VarDeclNode)decl, patternGraph);
			} else {
				throw new IllegalArgumentException("unknown Class: " + decl);
			}
		}
	}

	private void addReplacementNodeParamToNestedAlternativesAndIterateds(NodeDeclNode decl, PatternGraph patternGraph) {
		for(Alternative alt : patternGraph.getAlts()) {
			for(Rule altCase : alt.getAlternativeCases()) {
				altCase.getRight().addReplParameter(decl.checkIR(Node.class));
				altCase.getRight().addSingleNode(decl.getNode());
			}
		}
		for(Rule iter : patternGraph.getIters()) {
			iter.getRight().addReplParameter(decl.checkIR(Node.class));
			iter.getRight().addSingleNode(decl.getNode());
		}
	}

	private void addReplacementVarParamToNestedAlternativesAndIterateds(VarDeclNode decl, PatternGraph patternGraph) {
		for(Alternative alt : patternGraph.getAlts()) {
			for(Rule altCase : alt.getAlternativeCases()) {
				altCase.getRight().addReplParameter(decl.checkIR(Variable.class));
				altCase.getRight().addVariable(decl.getVariable());
			}
		}
		for(Rule iter : patternGraph.getIters()) {
			iter.getRight().addReplParameter(decl.checkIR(Variable.class));
			iter.getRight().addVariable(decl.getVariable());
		}
	}

	/**
	 * add NACs for induced- or DPO-semantic
	 */
	protected void constructImplicitNegs(PatternGraph left) {
		PatternGraphNode leftNode = pattern;
		for(PatternGraph neg : leftNode.getImplicitNegGraphs()) {
			left.addNegGraph(neg);
		}
	}
	
	// TODO use this to create IR patterns, that is currently not supported by
	//      any backend
	/*private IR constructPatternIR() {
		PatternGraph left = pattern.getPatternGraph();

		// return if the pattern graph already constructed the IR object
		// that may happens in recursive patterns
		if (isIRAlreadySet()) {
			return getIR();
		}

		Vector<PatternGraph> right = new Vector<PatternGraph>();
		for (int i = 0; i < this.right.children.size(); i++) {
			right.add(this.right.children.get(i).getPatternGraph(left));
		}

		// return if the pattern graph already constructed the IR object
		// that may happens in recursive patterns
		if (isIRAlreadySet()) {
			return getIR();
		}

		Pattern pattern = new Pattern(getIdentNode().getIdent(), left, right);

		constructImplicitNegs(left);
		constructIRaux(pattern);

		// add Eval statements to the IR
		for (int i = 0; i < this.right.children.size(); i++) {
			for (Assignment n : this.right.children.get(i).getAssignments()) {
				pattern.addEval(i,n);
			}
		}

		return pattern;
	}*/
}
