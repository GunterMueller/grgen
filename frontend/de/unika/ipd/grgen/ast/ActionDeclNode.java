/*
 * GrGen: graph rewrite generator tool -- release GrGen.NET 4.5
 * Copyright (C) 2003-2020 Universitaet Karlsruhe, Institut fuer Programmstrukturen und Datenorganisation, LS Goos; and free programmers
 * licensed under LGPL v3 (see LICENSE.txt included in the packaging of this file)
 * www.grgen.net
 */

/**
 * @author shack
 */

package de.unika.ipd.grgen.ast;

import de.unika.ipd.grgen.ir.Rule;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;

/**
 * Base class for all action type ast nodes
 */
// TODO: a lot of code duplication among the subtypes of ActionDeclNode,
// fix the copy'n'paste programming by extracting the common stuff to action node,
// with parameters giving access to the left/right patterns.
// First step: remove the ability for multiple right sides, not needed in practice (0 or 1 RHS allowed)
// (maybe a test must be modeled as a rule with 0 RHS in order to be able to unify with the other action decl nodes)
public abstract class ActionDeclNode extends DeclNode
{
	public ActionDeclNode(IdentNode id, TypeNode type) {
		super(id, type);
	}

	/**
	 * Get the IR object for this action node.
	 * The IR object is instance of Rule.
	 * @return The IR object.
	 */
	protected Rule getAction() {
		return checkIR(Rule.class);
	}

	protected PatternGraphNode getParentPatternGraph(BaseNode node) {
		if (node == null) {
			return null;
		}

		Queue<Collection<BaseNode>> queue = new LinkedList<Collection<BaseNode>>();
		for (Collection<BaseNode> parents = node.getParents(); parents != null; parents = queue.poll()) {
			for (BaseNode parent : parents) {
				if (parent instanceof PatternGraphNode) {
					return (PatternGraphNode)parent;
				}
				Collection<BaseNode> grandParents = parent.getParents();
				if (grandParents != null && !grandParents.isEmpty()) {
					queue.add(grandParents);
				}
			}
		}

		return null;
	}

	protected boolean resolveFilters(ArrayList<FilterAutoNode> filters) {
		boolean filtersOk = true;
		for(FilterAutoNode filter : filters) {
			if(filter instanceof FilterAutoSuppliedNode) {
				filtersOk &= ((FilterAutoSuppliedNode)filter).resolve();
			} else { //if(filter instanceof FilterAutoGeneratedNode)
				filtersOk &= ((FilterAutoGeneratedNode)filter).resolve();
			}
		}
		return filtersOk;
	}

	protected boolean checkFilters(PatternGraphNode pattern, ArrayList<FilterAutoNode> filters) {
		boolean allFilterEntitiesExistAndAreOfAdmissibleType = true;
		HashSet<String> alreadySeenFilters = new HashSet<String>();
		for(FilterAutoNode fa : filters) {
			if(fa instanceof FilterAutoGeneratedNode) {
				FilterAutoGeneratedNode filter = (FilterAutoGeneratedNode)fa;
				String filterNameWithEntitySuffix = filter.getFilterNameWithEntitySuffix();
				if(alreadySeenFilters.contains(filterNameWithEntitySuffix)) {
					reportError(filterNameWithEntitySuffix + " was already declared, only one declaration admissible.");
					allFilterEntitiesExistAndAreOfAdmissibleType = false;
				} else {
					alreadySeenFilters.add(filterNameWithEntitySuffix);
				}
				if(filter.name.equals("orderAscendingBy") || filter.name.equals("orderDescendingBy")
					|| filter.name.equals("groupBy") || filter.name.equals("keepSameAsFirst")
					|| filter.name.equals("keepSameAsLast") || filter.name.equals("keepOneForEach")) {
					for(String filterEntity : filter.entities) {
						allFilterEntitiesExistAndAreOfAdmissibleType &= checkFilterVariable(pattern, filterNameWithEntitySuffix, filterEntity);
					}
					if(filter.name.equals("groupBy") || filter.name.equals("keepSameAsFirst")
						|| filter.name.equals("keepSameAsLast") || filter.name.equals("keepOneForEach")) {
						if(filter.entities.size()!=1) {
							reportError(filterNameWithEntitySuffix + " must be declared with exactly one variable, but is declared with " + filter.entities.size() + " variables");
							allFilterEntitiesExistAndAreOfAdmissibleType = false;
						}
					}
				}
			}
		}
		return allFilterEntitiesExistAndAreOfAdmissibleType;
	}

	private boolean checkFilterVariable(PatternGraphNode pattern, String filterNameWithEntitySuffix, String filterVariable) {
		if(pattern.getVariable(filterVariable)==null) {
			reportError(filterNameWithEntitySuffix + ": unknown variable " + filterVariable);
			return false;
		}
		TypeNode filterVariableType = pattern.getVariable(filterVariable).getDeclType();
		if(!filterVariableType.isFilterableType()) {
			reportError(filterNameWithEntitySuffix + ": the variable " + filterVariable + " must be of one of the following types: " + filterVariableType.getFilterableTypesAsString());
			return false;
		}
		return true;
	}
}
