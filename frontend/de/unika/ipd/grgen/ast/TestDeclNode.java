/*
 * GrGen: graph rewrite generator tool -- release GrGen.NET 4.5
 * Copyright (C) 2003-2020 Universitaet Karlsruhe, Institut fuer Programmstrukturen und Datenorganisation, LS Goos; and free programmers
 * licensed under LGPL v3 (see LICENSE.txt included in the packaging of this file)
 * www.grgen.net
 */

/**
 * @author shack
 */

package de.unika.ipd.grgen.ast;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Set;
import java.util.Vector;

import de.unika.ipd.grgen.ast.exprevals.*;
import de.unika.ipd.grgen.ast.util.CollectResolver;
import de.unika.ipd.grgen.ast.util.DeclarationTypeResolver;
import de.unika.ipd.grgen.ir.DefinedMatchType;
import de.unika.ipd.grgen.ir.Edge;
import de.unika.ipd.grgen.ir.Entity;
import de.unika.ipd.grgen.ir.exprevals.Expression;
import de.unika.ipd.grgen.ir.FilterAutoGenerated;
import de.unika.ipd.grgen.ir.FilterFunction;
import de.unika.ipd.grgen.ir.IR;
import de.unika.ipd.grgen.ir.MatchingAction;
import de.unika.ipd.grgen.ir.PatternGraph;
import de.unika.ipd.grgen.ir.Rule;


/**
 * AST node class representing tests
 */
public class TestDeclNode extends ActionDeclNode {
	static {
		setName(TestDeclNode.class, "test declaration");
	}

	protected CollectNode<BaseNode> returnFormalParametersUnresolved;
	protected CollectNode<TypeNode> returnFormalParameters;
	protected ArrayList<FilterCharacter> filters;
	private TestTypeNode type;
	protected PatternGraphNode pattern;
	protected CollectNode<IdentNode> implementedMatchTypesUnresolved;
	protected CollectNode<DefinedMatchTypeNode> implementedMatchTypes;

	private static final TypeNode testType = new TestTypeNode();

	protected TestDeclNode(IdentNode id, TypeNode type, PatternGraphNode pattern, CollectNode<IdentNode> implementedMatchTypes,
							CollectNode<BaseNode> rets) {
		super(id, type);
		this.returnFormalParametersUnresolved = rets;
		becomeParent(this.returnFormalParametersUnresolved);
		this.pattern = pattern;
		becomeParent(this.pattern);
		implementedMatchTypesUnresolved	= implementedMatchTypes;
		becomeParent(implementedMatchTypesUnresolved);
	}

	public TestDeclNode(IdentNode id, PatternGraphNode pattern, CollectNode<IdentNode> implementedMatchTypes,
			CollectNode<BaseNode> rets) {
		this(id, testType, pattern, implementedMatchTypes, rets);
	}

	public void addFilters(ArrayList<FilterCharacter> filters) {
		this.filters = filters;
	}

	/** returns children of this node */
	@Override
	public Collection<BaseNode> getChildren() {
		Vector<BaseNode> children = new Vector<BaseNode>();
		children.add(ident);
		children.add(getValidVersion(typeUnresolved, type));
		children.add(getValidVersion(returnFormalParametersUnresolved, returnFormalParameters));
		children.add(pattern);
		children.add(getValidVersion(implementedMatchTypesUnresolved, implementedMatchTypes));
		return children;
	}

	/** returns names of the children, same order as in getChildren */
	@Override
	public Collection<String> getChildrenNames() {
		Vector<String> childrenNames = new Vector<String>();
		childrenNames.add("ident");
		childrenNames.add("type");
		childrenNames.add("ret");
		childrenNames.add("pattern");
		childrenNames.add("implementedMatchTypes");
		return childrenNames;
	}

	private static final DeclarationTypeResolver<TestTypeNode> typeResolver = new DeclarationTypeResolver<TestTypeNode>(TestTypeNode.class);
	private static final CollectResolver<DefinedMatchTypeNode> matchTypeResolver = new CollectResolver<DefinedMatchTypeNode>(
			new DeclarationTypeResolver<DefinedMatchTypeNode>(DefinedMatchTypeNode.class));
	private static final CollectResolver<TypeNode> retTypeResolver = new CollectResolver<TypeNode>(
			new DeclarationTypeResolver<TypeNode>(TypeNode.class));

	/** @see de.unika.ipd.grgen.ast.BaseNode#resolveLocal() */
	@Override
	protected boolean resolveLocal() {
		type = typeResolver.resolve(typeUnresolved, this);
		for(IdentNode mtid : implementedMatchTypesUnresolved.getChildren()) {
			if(!(mtid instanceof PackageIdentNode)) {
				fixupDefinition(mtid, mtid.getScope());
			}
		}
		implementedMatchTypes = matchTypeResolver.resolve(implementedMatchTypesUnresolved, this);
		returnFormalParameters = retTypeResolver.resolve(returnFormalParametersUnresolved, this);

		boolean filtersOk = true;
		for(FilterCharacter filter : filters) {
			if(filter instanceof FilterFunctionDeclNode) {
				filtersOk &= ((FilterFunctionDeclNode)filter).resolve();
			} else { //if(filter instanceof FilterAutoGeneratedNode)
				filtersOk &= ((FilterAutoGeneratedNode)filter).resolve();
			}
		}

		return type != null && returnFormalParameters != null && implementedMatchTypes != null && filtersOk;
	}

	/**
	 * Check if actual return arguments are conformant to the formal return parameters.
	 */
	// TODO is this method called twice for RuleDeclNode?
	protected boolean checkReturns(CollectNode<ExprNode> returnArgs) {
		boolean res = true;

		int declaredNumRets = returnFormalParameters.size();
		int actualNumRets = returnArgs.size();
retLoop:for (int i = 0; i < Math.min(declaredNumRets, actualNumRets); i++) {
			ExprNode retExpr = returnArgs.get(i);
			TypeNode retExprType = retExpr.getType();

			TypeNode retDeclType = returnFormalParameters.get(i);
			if(!retExprType.isCompatibleTo(retDeclType)) {
				res = false;
				String exprTypeName;
				if(retExprType instanceof InheritanceTypeNode)
					exprTypeName = ((InheritanceTypeNode) retExprType).getIdentNode().toString();
				else
					exprTypeName = retExprType.toString();
				ident.reportError("Cannot convert " + (i + 1) + ". return parameter from \""
						+ exprTypeName + "\" to \"" + returnFormalParameters.get(i).toString() + "\"");
				continue;
			}

			if(!(retExpr instanceof DeclExprNode)) continue;
			ConstraintDeclNode retElem = ((DeclExprNode) retExpr).getConstraintDeclNode();
			if(retElem == null) continue;

			InheritanceTypeNode declaredRetType = retElem.getDeclType();

			Set<? extends ConstraintDeclNode> homSet;
			if(retElem instanceof NodeDeclNode)
				homSet = pattern.getHomomorphic((NodeDeclNode) retElem);
			else
				homSet = pattern.getHomomorphic((EdgeDeclNode) retElem);

			for(ConstraintDeclNode homElem : homSet) {
				if(homElem == retElem) continue;

				ConstraintDeclNode retypedElem = homElem.getRetypedElement();
				if(retypedElem == null) continue;

				InheritanceTypeNode retypedElemType = retypedElem.getDeclType();
				if(retypedElemType.isA(declaredRetType)) continue;

				res = false;
				returnArgs.reportError("Return parameter \"" + retElem.getIdentNode() + "\" is homomorphic to \""
						+ homElem.getIdentNode() + "\", which gets retyped to the incompatible type \""
						+ retypedElemType.getIdentNode() + "\"");
				continue retLoop;
			 }
		}

		//check the number of returned elements
		if (actualNumRets != declaredNumRets) {
			res = false;
			if (declaredNumRets == 0) {
				returnArgs.reportError("No return values declared for rule \"" + ident + "\"");
			} else if(actualNumRets == 0) {
				reportError("Missing return statement for rule \"" + ident + "\"");
			} else {
				returnArgs.reportError("Return statement has wrong number of parameters");
			}
		}
		return res;
	}

	private boolean SameNumberOfRewriteParts() {
		boolean res = true;

		for(AlternativeNode alt : pattern.alts.getChildren()) {
			for(AlternativeCaseNode altCase : alt.getChildren()) {
				if(altCase.right.getChildren().size() != 0) {
					error.error(getCoords(), "Different number of replacement patterns/rewrite parts in test " + ident.toString()
							+ " and nested alternative case " + altCase.ident.toString());
					res = false;
					continue;
				}
			}
		}

		for(IteratedNode iter : pattern.iters.getChildren()) {
			if(iter.right.getChildren().size() != 0) {
				error.error(getCoords(), "Different number of replacement patterns/rewrite parts in test " + ident.toString()
						+ " and nested iterated/multiple/optional " + iter.ident.toString());
				res = false;
				continue;
			}
		}

		return res;
	}

	@Override
	protected boolean checkLocal() {
		boolean childs = true;

		// check if reused names of edges connect the same nodes in the same direction with the same edge kind for each usage
		boolean edgeReUse = false;
		if (childs) {
			edgeReUse = true;

			//get the negative graphs and the pattern of this TestDeclNode
			// NOTE: the order affect the error coords
			Collection<PatternGraphNode> leftHandGraphs = new LinkedList<PatternGraphNode>();
			leftHandGraphs.add(pattern);
			for (PatternGraphNode pgn : pattern.negs.getChildren()) {
				leftHandGraphs.add(pgn);
			}

			GraphNode[] graphs = leftHandGraphs.toArray(new GraphNode[0]);
			Collection<EdgeCharacter> alreadyReported = new HashSet<EdgeCharacter>();

			for (int i=0; i<graphs.length; i++) {
				for (int o=i+1; o<graphs.length; o++) {
					for (BaseNode iBN : graphs[i].getConnections()) {
						if (! (iBN instanceof ConnectionNode)) {
							continue;
						}
						ConnectionNode iConn = (ConnectionNode)iBN;

						for (BaseNode oBN : graphs[o].getConnections()) {
							if (! (oBN instanceof ConnectionNode)) {
								continue;
							}
							ConnectionNode oConn = (ConnectionNode)oBN;

							if (iConn.getEdge().equals(oConn.getEdge()) && !alreadyReported.contains(iConn.getEdge())) {
								NodeCharacter oSrc, oTgt, iSrc, iTgt;
								oSrc = oConn.getSrc();
								oTgt = oConn.getTgt();
								iSrc = iConn.getSrc();
								iTgt = iConn.getTgt();

								assert ! (oSrc instanceof NodeTypeChangeNode):
									"no type changes in test actions";
								assert ! (oTgt instanceof NodeTypeChangeNode):
									"no type changes in test actions";
								assert ! (iSrc instanceof NodeTypeChangeNode):
									"no type changes in test actions";
								assert ! (iTgt instanceof NodeTypeChangeNode):
									"no type changes in test actions";

								//check only if there's no dangling edge
								if ( !((iSrc instanceof NodeDeclNode) && ((NodeDeclNode)iSrc).isDummy())
									&& !((oSrc instanceof NodeDeclNode) && ((NodeDeclNode)oSrc).isDummy())
									&& iSrc != oSrc ) {
									alreadyReported.add(iConn.getEdge());
									iConn.reportError("Reused edge does not connect the same nodes");
									edgeReUse = false;
								}

								//check only if there's no dangling edge
								if ( !((iTgt instanceof NodeDeclNode) && ((NodeDeclNode)iTgt).isDummy())
									&& !((oTgt instanceof NodeDeclNode) && ((NodeDeclNode)oTgt).isDummy())
									&& iTgt != oTgt && !alreadyReported.contains(iConn.getEdge())) {
									alreadyReported.add(iConn.getEdge());
									iConn.reportError("Reused edge does not connect the same nodes");
									edgeReUse = false;
								}


								if (iConn.getConnectionKind() != oConn.getConnectionKind()) {
									alreadyReported.add(iConn.getEdge());
									iConn.reportError("Reused edge does not have the same connection kind");
									edgeReUse = false;
								}
							}
						}
					}
				}
			}
		}

		boolean returnParams = true;
		if(!(this instanceof RuleDeclNode))
			returnParams = checkReturns(pattern.returns);

		boolean noRewriteParts = true;
		if(!(this instanceof RuleDeclNode))
			noRewriteParts = SameNumberOfRewriteParts();

		return checkFilters() && noRewriteParts && childs && edgeReUse && returnParams && checkMatchTypesImplemented();
	}

	public boolean checkMatchTypesImplemented()
	{
		boolean isOk = true;
		
		for(DefinedMatchTypeNode matchType : implementedMatchTypes.getChildren()) {
			isOk &= checkMatchTypeImplemented(matchType);
		}
		
		return isOk;
	}

	public boolean checkMatchTypeImplemented(DefinedMatchTypeNode matchType)
	{
		boolean isOk = true;
		
		String actionName = getIdentNode().toString();
		String matchTypeName = matchType.getIdentNode().toString();
		
		HashMap<String, NodeDeclNode> knownNodes = new HashMap<String, NodeDeclNode>();
		for(NodeDeclNode node : pattern.getNodes()) {
			knownNodes.put(node.getIdentNode().toString(), node);
		}

		for(NodeDeclNode node : matchType.getNodes()) {
			String nodeName = node.getIdentNode().toString();
			if(!knownNodes.containsKey(nodeName)) {
				getIdentNode().reportError("Action " + actionName + " does not implement the node " + nodeName + " expected from " + matchTypeName);
				isOk = false;
			} else {
				NodeDeclNode nodeFromPattern = knownNodes.get(nodeName);
				NodeTypeNode type = node.getDeclType();
				NodeTypeNode typeOfNodeFromPattern = nodeFromPattern.getDeclType();
				if(!type.isEqual(typeOfNodeFromPattern)) {
					getIdentNode().reportError("The type of the node " + nodeName + " from the action " + actionName + " does not equal the type of the node from the match class " + matchTypeName 
							+ ". In the match class, " + getTypeName(type) + " is declared, but in the pattern, " + getTypeName(typeOfNodeFromPattern) + " is declared.");
					isOk = false;
				}
			}
		}

		HashMap<String, EdgeDeclNode> knownEdges = new HashMap<String, EdgeDeclNode>();
		for(EdgeDeclNode edge : pattern.getEdges()) {
			knownEdges.put(edge.getIdentNode().toString(), edge);
		}

		for(EdgeDeclNode edge: matchType.getEdges()) {
			String edgeName = edge.getIdentNode().toString();
			if(!knownEdges.containsKey(edgeName)) {
				getIdentNode().reportError("Action " + actionName + " does not implement the edge " + edgeName + " expected from " + matchTypeName);
				isOk = false;
			} else {
				EdgeDeclNode edgeFromPattern = knownEdges.get(edgeName);
				EdgeTypeNode type = edge.getDeclType();
				EdgeTypeNode typeOfEdgeFromPattern = edgeFromPattern.getDeclType();
				if(!type.isEqual(typeOfEdgeFromPattern)) {
					getIdentNode().reportError("The type of the edge " + edgeName + " from the action " + actionName + " does not equal the type of the edge from the match class " + matchTypeName 
							+ ". In the match class, " + getTypeName(type) + " is declared, but in the pattern, " + getTypeName(typeOfEdgeFromPattern) + " is declared.");
					isOk = false;
				}
			}
		}

		HashMap<String, VarDeclNode> knownVariables = new HashMap<String, VarDeclNode>();
		for(VarDeclNode var : pattern.getDefVariablesToBeYieldedTo().getChildren()) {
			knownVariables.put(var.getIdentNode().toString(), var);
		}

		for(VarDeclNode var : matchType.getDefVariablesToBeYieldedTo()) {
			String varName = var.getIdentNode().toString();
			if(!knownVariables.containsKey(varName)) {
				getIdentNode().reportError("Action " + actionName + " does not implement the def variable " + varName + " expected from " + matchTypeName);
				isOk = false;
			} else {
				VarDeclNode varFromPattern = knownVariables.get(varName);
				TypeNode type = var.getDeclType();
				TypeNode typeOfVarFromPattern = varFromPattern.getDeclType();
				if(!type.isEqual(typeOfVarFromPattern)) {
					getIdentNode().reportError("The type of the variable " + varName + " from the action " + actionName + " does not equal the type of the variable from the match class " + matchTypeName 
							+ ". In the match class, " + getTypeName(type) + " is declared, but in the pattern, " + getTypeName(typeOfVarFromPattern) + " is declared.");
					isOk = false;
				}
			}
		}

		return isOk;
	}

	private String getTypeName(TypeNode type) {
		String typeName;
		if(type instanceof InheritanceTypeNode)
			typeName = ((InheritanceTypeNode) type).getIdentNode().toString();
		else
			typeName = type.toString();
		return typeName;
	}

	public boolean checkControlFlow() {
		return true;
	}

	private boolean checkFilters() {
		boolean allFilterEntitiesExistAndAreOfAdmissibleType = true;
		for(FilterCharacter fc : filters) {
			if(fc instanceof FilterAutoGeneratedNode) {
				FilterAutoGeneratedNode filter = (FilterAutoGeneratedNode)fc;
				if(filter.name.equals("orderAscendingBy") || filter.name.equals("orderDescendingBy")
					|| filter.name.equals("groupBy") || filter.name.equals("keepSameAsFirst")
					|| filter.name.equals("keepSameAsLast") || filter.name.equals("keepOneForEach")) {
					for(String filterEntity : filter.entities) {
						allFilterEntitiesExistAndAreOfAdmissibleType &= checkFilterVariable(filter.name, filterEntity);
					}
					if(filter.name.equals("groupBy") || filter.name.equals("keepSameAsFirst")
						|| filter.name.equals("keepSameAsLast") || filter.name.equals("keepOneForEach")) {
						if(filter.entities.size()!=1) {
							reportError(filter.name + " must be declared with exactly one variable, but is declared with " + filter.entities.size() + " variables");
						}
					}
				}
			}
		}
		return allFilterEntitiesExistAndAreOfAdmissibleType;
	}

	private boolean checkFilterVariable(String filterBase, String filterVariable) {
		if(getVariable(filterVariable)==null) {
			reportError(filterBase + "<" + filterVariable + ">: unknown variable " + filterVariable);
			return false;
		}
		if(!isFilterableType(getVariable(filterVariable).getDeclType())) {
			reportError(filterBase + "<" + filterVariable + ">: the variable " + filterVariable + " must be of one of the following types: byte, short, int, long, float, double, string");
			return false;
		}
		return true;
	}

	private boolean isFilterableType(TypeNode givenType) {
		if(givenType.isEqual(BasicTypeNode.byteType))
			return true;
		if(givenType.isEqual(BasicTypeNode.shortType))
			return true;
		if(givenType.isEqual(BasicTypeNode.intType))
			return true;
		if(givenType.isEqual(BasicTypeNode.longType))
			return true;
		if(givenType.isEqual(BasicTypeNode.floatType))
			return true;
		if(givenType.isEqual(BasicTypeNode.doubleType))
			return true;
		if(givenType.isEqual(BasicTypeNode.stringType))
			return true;
		return false;
	}

	private VarDeclNode getVariable(String name) {
		for(VarDeclNode var : pattern.getDefVariablesToBeYieldedTo().getChildren()) {
			if(var.getIdentNode().toString().equals(name))
				return var;
		}
		return null;
	}

	public Collection<DefinedMatchTypeNode> getImplementedMatchClasses() {
		return implementedMatchTypes.getChildren();
	}

	protected void constructIRaux(MatchingAction ma, CollectNode<ExprNode> aReturns) {
		PatternGraph patternGraph = ma.getPattern();

		// add Params to the IR
		for(DeclNode decl : pattern.getParamDecls()) {
			ma.addParameter(decl.checkIR(Entity.class));

			// TODO: parameters were already added to the graph -> needed here again?
			if(decl instanceof NodeCharacter) {
				patternGraph.addSingleNode(((NodeCharacter)decl).getNode());
			} else if (decl instanceof EdgeCharacter) {
				Edge e = ((EdgeCharacter)decl).getEdge();
				patternGraph.addSingleEdge(e);
			} else if(decl instanceof VarDeclNode) {
				patternGraph.addVariable(((VarDeclNode) decl).getVariable());
			} else {
				throw new IllegalArgumentException("unknown Class: " + decl);
			}
		}

		// add Return-Params to the IR
		for(ExprNode aReturnAST : aReturns.getChildren()) {
			Expression aReturn = aReturnAST.checkIR(Expression.class);
			// actual return-parameter
			ma.addReturn(aReturn);
		}
		
		// filters add themselves to the rule when their IR is constructed
		for(FilterCharacter filter : filters) {
			if(filter instanceof FilterFunctionDeclNode) {
				((FilterFunctionDeclNode)filter).checkIR(FilterFunction.class);
			} else { //if(filter instanceof FilterAutoGeneratedNode)
				((FilterAutoGeneratedNode)filter).checkIR(FilterAutoGenerated.class);
			}
		}
	}

	@Override
	public TypeNode getDeclType() {
		assert isResolved();

		return type;
	}

	public static String getKindStr() {
		return "action declaration";
	}

	public static String getUseStr() {
		return "action";
	}
	
	public NodeDeclNode tryGetNode(IdentNode ident) {
		for(NodeDeclNode node : pattern.getNodes()) {
			if(node.ident.toString().equals(ident.toString()))
				return node;
		}
		return null;
	}

	public EdgeDeclNode tryGetEdge(IdentNode ident) {
		for(EdgeDeclNode edge : pattern.getEdges()) {
			if(edge.ident.toString().equals(ident.toString()))
				return edge;
		}
		return null;
	}

	public VarDeclNode tryGetVar(IdentNode ident) {
		for(VarDeclNode var : pattern.defVariablesToBeYieldedTo.getChildren()) {
			if(var.ident.toString().equals(ident.toString()))
				return var;
		}
		for(DeclNode varCand : pattern.getParamDecls()) {
			if(!(varCand instanceof VarDeclNode))
				continue;
			VarDeclNode var = (VarDeclNode)varCand;
			if(var.ident.toString().equals(ident.toString()))
				return var;
		}
		return null;
	}

	@Override
	protected IR constructIR() {
		PatternGraph left = pattern.getPatternGraph();

		// return if the pattern graph already constructed the IR object
		// that may happens in recursive patterns
		if (isIRAlreadySet()) {
			return getIR();
		}

		Rule testRule = new Rule(getIdentNode().getIdent(), left, null);

		// mark this node as already visited
		setIR(testRule);

		for(DefinedMatchTypeNode implementedMatchClassNode : implementedMatchTypes.getChildren()) {
			DefinedMatchType implementedMatchClass = implementedMatchClassNode.checkIR(DefinedMatchType.class);
			testRule.addImplementedMatchClass(implementedMatchClass);
		}

		constructImplicitNegs(left);
		constructIRaux(testRule, pattern.returns);

		return testRule;
	}

	/**
     * add NACs for induced- or DPO-semantic
     */
    protected void constructImplicitNegs(PatternGraph left)
    {
    	PatternGraphNode leftNode = pattern;
    	for (PatternGraph neg : leftNode.getImplicitNegGraphs()) {
    		left.addNegGraph(neg);
    	}
    }
}


